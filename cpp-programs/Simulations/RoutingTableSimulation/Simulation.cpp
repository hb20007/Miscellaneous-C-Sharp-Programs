#include "Simulation.h"

// Note the use of an initialization list in the constructor below, instead of assignment, for initiliazing the variables. This was neccessary because these variables have the const modifier and must be initialized in this manner
Simulation::Simulation(const int& nodesNumber, const int& maxConnectionCost) : numberOfNodes(nodesNumber), maxPathCost(maxConnectionCost) { }

int Simulation::main() {
	srand((unsigned int)time(0)); // time(0), which is of type time_t is casted to an unsigned int because this is what srand() expects as a parameter

	char selection;
	mainMenu(selection);
	if (selection != '1')
		return 0;
	cout << "\nTen nodes will be created and will be assigned random unreserved IP4 addresses\n";
	createNodes();
	cout << "\nList of nodes created:\n";
	displayListOfNodes();
	cout << "\nConnections between them will be created at random\nin such a way that at the end all Nodes\nare reachable from node A\n";
	createPaths();
	cout << "\nList of all connections between nodes:\n";
	displayConnections();
	generateNodeARoutingTable(); // Note that because of the nested loops used in this function, it may take a few seconds for the routing table to be generated if the random scenario created when the application is run has many Paths (30+)
	cout << "The routing table of router A is shown below\n";
	printNodeARoutingTable();

	while (userWantsToContinue()) {
		int numberOfUpdatesToOccur = rand() % 3 + 1; // At every interval, 1-3 random updates to the Paths occur
		unsigned int firstNodeIndex = -1, firstPathIndex = -1, secondNodeIndex = -1, secondPathIndex = -1; // These indexes are initialized to -1 in order to not cause problems when they are used before being given a value yet, see line 31
		for (int i = 0; i < numberOfUpdatesToOccur; i++) {
			unsigned int randomNodeIndex = rand() % numberOfNodes;
			unsigned int randomPathIndex = rand() % nodesArray[randomNodeIndex].getPaths().size();
			
			// If the random node index and the random path from that node are the same as in a previous update, they are randomly generated again. This is because in one update, the same Path should not be modified twice
			while ((randomNodeIndex == firstNodeIndex && randomPathIndex == firstPathIndex) || (randomNodeIndex == secondNodeIndex && randomPathIndex == secondPathIndex)) {
				randomNodeIndex = rand() % numberOfNodes;
				randomPathIndex = rand() % nodesArray[randomNodeIndex].getPaths().size();
			}
			
			// Note that in the call below, the first argument to specialRandomIntegerGenerate() is nodesArray[randomNodeIndex].getPaths().at(randomPathIndex).cost - 1 and not simply nodesArray[randomNodeIndex].getPaths().at(randomPathIndex).cost because the special random generator generates a number from 0 above while here we require a number from 1 above. Because we increment the random number generated by 1 aftwerwards, we need to perform the check to the number less than the cost
			unsigned int randomNewCost = Utility::specialRandomIntegerGenerate(nodesArray[randomNodeIndex].getPaths().at(randomPathIndex).cost - 1, maxPathCost) + 1;
			cout << "\nThe cost of the path from " << nodesArray[randomNodeIndex].getID() << " to " << nodesArray[randomNodeIndex].getPaths().at(randomPathIndex).destination->getID() << " changes from " << nodesArray[randomNodeIndex].getPaths().at(randomPathIndex).cost << " to " << randomNewCost << "!\n";
			cout << "\nRouter " << nodesArray[randomNodeIndex].getID() << " detects this change\nIt broadcasts a signal with the new cost of this path to all the other routers\nThis signal also contains a new sequence number and time stamp\n";
			nodesArray[randomNodeIndex].modifyPathCost(randomPathIndex, randomNewCost); // The change is registered in the Nodes array
			updateNodeARoutingTable(randomNodeIndex); // The change is registered in node A's routing table

			// The first randomly generated Node and Path index are saved in the case that more iterations will occur and in the case that they are indeed the first ones for the purpose of making sure that if the same ones will not be generated again by chance
			if ((i == 0 && numberOfUpdatesToOccur > 1) || (i == 0 && numberOfUpdatesToOccur == 2)) { 
				firstNodeIndex = randomNodeIndex;
				firstPathIndex = randomPathIndex;
			}
			
			// The second randomly generated Node and Path index are saved in case there is a third iteration
			if (i == 1 && numberOfUpdatesToOccur > 1) {
				secondNodeIndex = randomNodeIndex;
				secondPathIndex = randomPathIndex;
			}
		}
		cout << "\nThe list of all connections after this modification is shown below\n";
		displayConnections();
		cout << "Router A receieves the signal about the updated path(s) and recalculates\nthe best route to reach each Node\n";
		cout << "\nThe updated routing table for router A follows\n";
		printNodeARoutingTable();
	}
	return 0;
}

void Simulation::mainMenu(char& menuSelection) {
	cout << "Welcome to the Routing Table Simulator!\n\nThis program simulates the routing table of a router in a network with " << numberOfNodes << " nodes\n\nThe updating mechanism used for the routing table entries relies on the Destination-Sequenced Distance-Vector Routing (DSDV) scheme";
	cout << "\n\n1. Begin simulation";
	cout << "\n2. Exit program\n> ";
	cin >> menuSelection;
}

void Simulation::createNodes() {
	for (unsigned int i = 0; i < numberOfNodes; i++) { 
		Node newNode;
		newNode.setID((char)i + 65); // When i = 0, i + 65 casted to a character is 'A' etc...
		newNode.setIPAddress(Utility::generateIPAddress()); // The nodes are assigned random valid IP addresses every time the simulation is run
		nodesArray.push_back(newNode);
	}
}

void Simulation::displayListOfNodes() {
	for (unsigned int i = 0; i < numberOfNodes; i++)
		cout << nodesArray[i].getID() << " (IP address: " << nodesArray[i].getIPAddress() << ")\n";
}

void Simulation::createPaths() {
	for (unsigned int i = 0; i < numberOfNodes; i++) { // Creating the paths, step 1: One path is created from each Node to a random Node which is not itself and which does not have another path already leading to it. 
		int newDestinationNodeIndex;
		do newDestinationNodeIndex = Utility::specialRandomIntegerGenerate(i, numberOfNodes); // The special random integer generator is used in order to make sure that the random index generated does not represent the Node iteself
		while (Utility::pathToDestinationAlreadyExists(nodesArray[i].getPaths(), nodesArray[newDestinationNodeIndex]));
		Path newPath(rand() % maxPathCost + 1, &nodesArray[newDestinationNodeIndex]); // A new Path is created with a random cost and with a randomly chosen destination Node which is made sure to not be the same as the source Node using the specialRandomIntegerGenerate() function
		nodesArray[i].addPath(newPath);
	}
	while (nodesArray[0].nodesReachableFromThisNode().size() < numberOfNodes) { // Creating the paths, step 2: A completely random connection is made between any 2 Nodes . This is repeated until all the Nodes can be reachable from Node A which means that node A will have a routing table with 10 entries.
		int indexOfNodeToCreatePathFor = rand() % numberOfNodes;
		int newDestinationNodeIndex;
		do newDestinationNodeIndex = Utility::specialRandomIntegerGenerate(indexOfNodeToCreatePathFor, numberOfNodes);
		while (Utility::pathToDestinationAlreadyExists(nodesArray[indexOfNodeToCreatePathFor].getPaths(), nodesArray[newDestinationNodeIndex]));
		Path newPath(rand() % maxPathCost + 1, &nodesArray[newDestinationNodeIndex]);
		nodesArray[indexOfNodeToCreatePathFor].addPath(newPath);
	}
}

void Simulation::displayConnections() { // Also displays the total number of connections in the simulation
	int pathsCounter = 0;
	for (unsigned int i = 0; i < numberOfNodes; i++) {
		for (unsigned int j = 0; j < nodesArray[i].getPaths().size(); j++) {
			cout << nodesArray[i].getID() << " --" << nodesArray[i].getPaths().at(j).cost << "--> " << nodesArray[i].getPaths().at(j).destination->getID();
			pathsCounter++;
			if ((j + 1) < nodesArray[i].getPaths().size())
				cout << "\t";
		}
		cout << endl;
	}
	cout << "(Total number of connections: " << pathsCounter << ")\n\n"; // From running the simulation multiple times, it is evident that this number is usally between 15 and 35
}

void Simulation::generateNodeARoutingTable() {
	for (unsigned int i = 0; i < numberOfNodes; i++) { // The routing table for Node A, has an entry for each Node, including A itself
		RoutingEntry newRow;
		newRow.rowNumber = i + 1;
		newRow.destinationNodeID = nodesArray[i].getID();
		newRow.destinationNodeIPAddress = nodesArray[i].getIPAddress();
		unsigned int cost;
		Node nextInPath;
		nodesArray[0].routeInfoToNode(nodesArray[i], cost, nextInPath); // The cost and the next Node in path are returned as reference parameters
		newRow.nextNodeID = nextInPath.getID();
		newRow.metric = cost;
		newRow.portNumber = rand() % 999 + 1; // The port numbers used are at maximum 3 digits long for simplicity
		string seqNo = "";
		unsigned int randomSequenceInteger = rand() % 500 + 1; // The sequence integer in the initial sequence numbers are all less than 500. Then, when the sequence numbers are update, they are incremented by a random number less than 50
		seqNo += nodesArray[i].getID();
		seqNo += '-';
		seqNo += to_string(randomSequenceInteger); // PS: The format for a sequence number is an identifier correpsonding to the Node from which information about the entry was received, a hyphen, and then a 3-digit integer which increases as the entry is updated
		newRow.sequenceNumber = seqNo;
		newRow.sequenceNumberReference = randomSequenceInteger;
		time_t now = time(0);
		tm *ltm = localtime(&now);
		string currentTime = "";
		currentTime += to_string(1 + ltm->tm_hour);
		currentTime += ':';
		int currentMinute = 1 + ltm->tm_min;
		int currentSecond = 1 + ltm->tm_sec;
		if (currentMinute < 10) // So that minutes less than 10 are displayed correctly
			currentTime += '0';
		currentTime += to_string(currentMinute);
		currentTime += '.';
		if (currentSecond < 10) // So that seconds less than 10 are displayed correctly
			currentTime += '0';
		currentTime += to_string(currentSecond); 
		newRow.time = currentTime; // The time routing entry is the current system time and includes hours, minutes as well as seconds
		nodeARoutingTable.addTableEntry(newRow);
	}
}

void Simulation::printNodeARoutingTable() {
	cout << "\nDEST.\tDEST. IP\tNEXT\tPATH COST\tPORT\tSEQ. NO.   TIME\n"; // The routing table is displayed with appropriate tabbing
	for (unsigned int i = 0; i < nodeARoutingTable.getTableEntries().size(); i++) { // An unsigned integer iterator is used because the size() function in the vector class returns an unsigned integer
		cout << nodeARoutingTable.getTableEntries().at(i).destinationNodeID << "\t";
		cout << nodeARoutingTable.getTableEntries().at(i).destinationNodeIPAddress << "\t";
		cout << nodeARoutingTable.getTableEntries().at(i).nextNodeID << "\t";
		cout << nodeARoutingTable.getTableEntries().at(i).metric << "\t\t";
		cout << nodeARoutingTable.getTableEntries().at(i).portNumber << "\t";
		cout << setw(5) << nodeARoutingTable.getTableEntries().at(i).sequenceNumber << "      ";
		cout << nodeARoutingTable.getTableEntries().at(i).time << "\n";
	}
}

bool Simulation::userWantsToContinue() {
	char userInsertion;
	cout << "\nWould you like to continue running the simulation?\n(type 'y' to continue, or any other input to terminate the simulation)\n> ";
	cin >> userInsertion;
	return userInsertion == 'y' ? true : false;
}

void Simulation::updateNodeARoutingTable(unsigned int& modifiedNodeIndex) {
	for (unsigned int i = 0; i < numberOfNodes; i++) {
		unsigned int cost;
		Node nextInPath;
		nodesArray[0].routeInfoToNode(nodesArray[i], cost, nextInPath); // After the Path updates, the algorithm is re-run in order to find again the best path to the Node and its cost
		nodeARoutingTable.modifyNextNodeID(i, nextInPath.getID());
		nodeARoutingTable.modifyMetric(i, cost);
	}
	// The sequenc number is updated:
	string seqNo = "";
	int newSequenceInteger = nodeARoutingTable.getTableEntries().at(modifiedNodeIndex).sequenceNumberReference + (rand() % 50 + 1); 
	nodeARoutingTable.modifySequenceNoRef(modifiedNodeIndex, newSequenceInteger);
	seqNo += nodesArray[modifiedNodeIndex].getID();
	seqNo += '-';
	seqNo += to_string(newSequenceInteger);
	nodeARoutingTable.modifySequenceNo(modifiedNodeIndex, seqNo);
	// The time is updated:
	time_t now = time(0);
	tm *ltm = localtime(&now);
	string currentTime = "";
	currentTime += to_string(1 + ltm->tm_hour);
	currentTime += ':';
	int currentMinute = 1 + ltm->tm_min;
	int currentSecond = 1 + ltm->tm_sec;
	if (currentMinute < 10)
		currentTime += '0';
	currentTime += to_string(currentMinute);
	currentTime += '.';
	if (currentSecond < 10)
		currentTime += '0';
	currentTime += to_string(currentSecond);
	nodeARoutingTable.modifyTime(modifiedNodeIndex, currentTime);
}